**1번. 합병 정렬 (연결리스트ver)**
```c
# include <stdio.h>
# include <stdlib.h>
# define swap(x, y) do {int tmp = x; x = y; y = tmp;}while(0)
# pragma warning(disable:4996)

typedef struct node {
	struct node* next;
	int data;
}NODE;

NODE* getNode(int data) {
	NODE* node = (NODE*)malloc(sizeof(NODE));
	node->next = NULL;
	node->data = data;
	return node;
}

void insertNode(NODE* L, int data) { //노드 삽입
	NODE* horse = L;
	NODE* newnode = getNode(data);

	if (horse == NULL) {
		L = newnode;
		return;
	}

	while (horse->next != NULL) {
		horse = horse->next;
	}
	horse->next = newnode;
	return;
}

int removeNode(NODE* list) { //노드 삭제 (지금은 안 쓰임)
	NODE* horse = list;
	int tmp = horse->data;

	list = horse->next;
	free(horse);

	return tmp;
}

void printList(NODE* L) { //리스트 인쇄
	NODE* horse = L;

	while (horse != NULL) {
		printf(" %d", horse->data);
		horse = horse->next;
	}
	printf("\n");
	return;
}

void freeList(NODE* L) { 
	NODE* horse;
	while (L != NULL) {
		horse = L->next;
		free(L);
		L = horse;
	}
	L = NULL;
	return;
}
 
void partition(NODE* L, int k, NODE** L1, NODE** L2) { //두 개의 부리스트로 분할
	NODE* horse = L;
	*L1 = horse;

	for (int i = 0; i < k - 1; i++) {
		horse = horse->next;
	}
	*L2 = horse->next;
	horse->next = NULL;
	//printf("L1: ");
	//printList(L1);
	//printf("L2: ");
	//printList(L2);
	return;
}

NODE* merge(NODE* L1, NODE* L2) { //두 개의 정렬된 단일연결리스트를 하나로 합병
	NODE* L;
	if (L1 == NULL) return L2;
	if (L2 == NULL) return L1;

	if (L1->data > L2->data) { 
		L = L2;
		L2 = L2->next;
	}
	else {
		L = L1;
		L1 = L1->next;
	}

	NODE* horse = L;
	while (L1 != NULL && L2 != NULL) { 
		if (L1->data > L2->data) {
			horse->next = L2;
			L2 = L2->next;
		}
		else {
			horse->next = L1;
			L1 = L1->next;
		}
		horse = horse->next;
	}
	while (L1 != NULL) {
		horse->next = L1;
		L1 = L1->next;
		horse = horse->next;
	}
	while (L2 != NULL) {
		horse->next = L2;
		L2 = L2->next;
		horse = horse->next;
	}

	return L;
}

NODE* mergeSort(NODE* L, int n) { //합병 정렬 수행
	NODE* L1 = NULL, * L2 = NULL;

	if (n < 2) return L;

	partition(L, n / 2, &L1, &L2);

	L1 = mergeSort(L1, n / 2);
	L2 = mergeSort(L2, n - n / 2);

	L = merge(L1, L2);

	return L;
}

int main(void) {
	NODE* L = NULL;
	//NODE* T = L;

	int n;
	scanf("%d", &n);

	int i, data;
	for (i = 0; i < n; i++) {
		scanf("%d", &data);
		insertNode(&L, data);
	}

	L = mergeSort(L, n); //합병 정렬

	printList(L);
	freeList(L);
	return 0;
} 
```

**2번. 퀵 정렬**
```c
# include <stdio.h>
# include <stdlib.h>
# define swap(x, y) do {int tmp = x; x = y; y = tmp;}while(0)
# pragma warning(disable:4996)

int findPivot(int* arr, int leftidx, int rightidx) {
	int randidx;
	randidx = leftidx + rand() % (rightidx - leftidx + 1);
	return randidx;
}

void inPlacePartition(int* arr, int leftidx, int rightidx, int* a, int* b) {
	int pivotidx, pivot, i, left = leftidx, Right = rightidx;

	pivotidx = findPivot(arr, leftidx, rightidx);
	pivot = arr[pivotidx];
	swap(arr[pivotidx], arr[leftidx]);
	i = leftidx;

	while (i <= Right) {
		if (arr[i] < pivot) {
			swap(arr[i], arr[left]);
			i++;
			left++;
		}
		else if (arr[i] > pivot) {
			swap(arr[i], arr[Right]);
			Right--;
		}
		else {
			i++;
		}
	}
	*a = left;
	*b = Right;
	return;
}

void quickSort(int* arr, int leftidx, int rightidx) {
	if (leftidx >= rightidx)
		return;
	int a, b;

	inPlacePartition(arr, leftidx, rightidx, &a, &b);
	quickSort(arr, leftidx, a - 1);
	quickSort(arr, b + 1, rightidx);
}

int main() {
	int n;
	scanf("%d", &n);

	int* arr = (int*)malloc(n * sizeof(int));

	for (int i = 0; i < n; i++) {
		scanf("%d", &arr[i]);
	}

	quickSort(arr, 0, n - 1);

	for (int i = 0; i < n; i++) {
		printf(" %d", arr[i]);
	}

	free(arr);
	return 0;
}
```
