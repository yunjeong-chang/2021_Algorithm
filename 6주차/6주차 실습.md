**1번&2번. 이진탐색**
```c
# include <stdio.h>
# include <stdlib.h>
# define swap(x, y) do {int tmp = x; x = y; y = tmp;}while(0)
# pragma warning(disable:4996)

int BinarySearch(int* arr, int start, int end, int key) { //이진탐색 (재귀ver)
	if (start > end) {
		return end; //end로 하면 key보다 작은 최대값, start로 하면 key보다 큰 최소값
	}
	int mid = (start + end) / 2;

	if (arr[mid] < key) {
		BinarySearch(arr, mid + 1, end, key);
	}
	else if (arr[mid] > key) {
		BinarySearch(arr, start, mid - 1, key);
	}
	else
		return mid;
}

int BinarySearch2(int* arr, int start, int end, int key) { //이진탐색 (비재귀ver)
	int mid = (start + end) / 2;

	while (start <= end) {
		if (arr[mid] < key) {
			start = mid + 1;
			mid = (mid + 1 + end) / 2;
		}
		else if (arr[mid] > key) {
			end = mid - 1;
			mid = (start + mid - 1) / 2;
		}
		else
			return mid;
	}

	return start; //end로 하면 key보다 작은 최대값, start로 하면 key보다 큰 최소값
}

int main() {
	int n, k;
	scanf("%d %d", &n, &k); //배열의 크기 n, 탐색할 키 k

	int* arr = (int*)malloc(sizeof(int) * n);
	for (int i = 0; i < n; i++) {
		scanf("%d", &arr[i]);
	}
	printf(" %d", BinarySearch(arr, 0, n - 1, k)); //이진탐색(재귀ver) 수행
	//printf(" %d", BinarySearch2(arr, 0, n - 1, k)); //이진탐색(비재귀ver) 수행
	return 0;
}

```

**3번. 이진탐색응용 - 게임**
```c
# include <stdio.h>
# include <stdlib.h>
# define swap(x, y) do {int tmp = x; x = y; y = tmp;}while(0)
# pragma warning(disable:4996)

int BinarySearchSejong(int a, int b, int n, char* str) {
	for (int i = 0; i < n; i++) {
		int mid = (a + b) / 2;
		if (str[i] == 'Y') {
			a = mid + 1;
		}
		else if (str[i] == 'N') {
			b = mid;
		}
	}
	return a;
}

int main() {
	int a, b, n;
	scanf("%d %d %d", &a, &b, &n);
	getchar();

	char str[100];
	scanf("%s", str);

	printf("%d", BinarySearchSejong(a, b, n, str));
	return 0;
}
```

**이진탐색 번외. 단일모드배열의 최대값 or 최소값 찾기**
```c
# include <stdio.h>
# include <stdlib.h>
# pragma warning(disable:4996)
# define swap(x, y) do {int tmp = x; x = y; y = tmp;}while(0)

int result_key;

int IsUnimodalArray(int* arr, int start, int end) {
	int flag = 0;
	if (arr[start] < arr[start + 1]) //증가로 시작
		flag = 1;
	else if (arr[start] > arr[start + 1]) //감소로 시작
		flag = -1;

	while (start < end) {
		if (flag == 1 && arr[start] > arr[start + 1]) {//증가->감소
			flag = 11;
			result_key = arr[start];
		}
		if (flag == -1 && arr[start] < arr[start + 1]) { //감소->증가
			flag = -11;
			result_key = arr[start];
		}
		if (flag == 11 && arr[start] < arr[start + 1]) //증가->감소->증가
			return 0;
		if (flag == -11 && arr[start] > arr[start + 1]) //감소->증가->감소
			return 0;
		start++;
	}
	if (flag == 11) return 1;
	if (flag == -11) return -1;
}

int FindMaxOfUnimodalArray(int* arr, int start, int end) {
	while (start < end) {
		int mid = (start + end) / 2;
		//printf("\nmid:%d\n", arr[mid]);
		if (arr[mid] < arr[mid + 1])
			start = mid + 1;
		else
			end = mid;
	}
	return arr[start];
}

int FindMinOfUnimodalArray(int* arr, int start, int end) {
	while (start < end) {
		int mid = (start + end) / 2;
		//printf("\nmid:%d\n", arr[mid]);
		if (arr[mid] > arr[mid + 1])
			start = mid + 1;
		else
			end = mid;
	}
	return arr[start];
}

int main() {
	int n;
	scanf("%d", &n); //배열의 크기 n

	int* arr = (int*)malloc(sizeof(int) * n);
	for (int i = 0; i < n; i++) {
		scanf("%d", &arr[i]);
	}
	int result;
	result = IsUnimodalArray(arr, 0, n - 1);
	printf(" %d", result);

	if (result == 1) {
		printf(" %d", FindMaxOfUnimodalArray(arr, 0, n - 1));
	}
	if (result == -1) {
		printf(" %d", FindMinOfUnimodalArray(arr, 0, n - 1));
	}

	return 0;
}
```
