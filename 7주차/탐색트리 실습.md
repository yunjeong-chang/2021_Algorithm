**1번. 이진탐색트리**
```c
# include <stdio.h>
# include <stdlib.h>
# pragma warning(disable:4996)

# define swap(x, y) do {int tmp = x; x = y; y = tmp;}while(0)
# define FALSE 0
# define TRUE 1

typedef struct node {
	struct node* leftChild;
	struct node* rightChild;
	struct node* parent;
	int key;
}Node;

Node* root;

Node* getNode() {
	Node* horse = (Node*)malloc(sizeof(Node));
	horse->key = 0;
	horse->parent = horse->leftChild = horse->rightChild = NULL;
	return horse;
}

int isExternal(Node* tmp) { //노드가 외부노드인가?
	if (tmp->leftChild == NULL && tmp->rightChild == NULL)
		return TRUE;

	return FALSE;
}

Node* inOrderSucc(Node* tmp) { //노드의 중위순회 후계자 반환
	tmp = tmp->rightChild;
	while (!isExternal(tmp->leftChild)) { //내부노드이면(외부노드 판단의 반대)
		tmp = tmp->leftChild;
	}
	return tmp;
}

void expandExternal(Node* tmp) {
	Node* lChild = getNode();
	Node* rChild = getNode();
	lChild->parent = tmp;
	rChild->parent = tmp;
	tmp->leftChild = lChild;
	tmp->rightChild = rChild;
	return;
}

Node* findSibling(Node* tmp) {
	if (tmp->parent->leftChild == tmp)
		return tmp->parent->rightChild;

	return tmp->parent->leftChild;
}

Node* reduceExternal(Node* tmp) {
	Node* parent = tmp->parent;
	Node* sibling = findSibling(tmp);
	Node* grandParent = parent->parent;

	if (parent == root) {
		root = sibling;
		sibling->parent = NULL;
	}
	else {
		sibling->parent = grandParent;
		if (parent == grandParent->leftChild)
			grandParent->leftChild = sibling;
		else
			grandParent->rightChild = sibling;
	}
	free(tmp);
	free(parent);
	return sibling;
}

Node* treeSearch(Node* tmp, int key) { //키를 저장한 내부 노드 반환
	if (isExternal(tmp))
		return tmp;
	if (key == tmp->key)
		return tmp;
	else if (key < tmp->key)
		return treeSearch(tmp->leftChild, key);
	else
		return treeSearch(tmp->rightChild, key);
}

void insertItem(int key) { //키에 대한 노드 생성 및 트리에 삽입 - i
	Node* tmp = treeSearch(root, key);

	if (!isExternal(tmp))
		return;
	else {
		tmp->key = key;
		expandExternal(tmp);
		return;
	}
}

void findElement(int key) { //키에 대한 노드 출력 (없으면 X) - s
	Node* tmp = treeSearch(root, key);

	if (isExternal(tmp))
		printf("X\n");
	else
		printf("%d\n", tmp->key);
	return;
}

void removeElement(int key) { //키에 대한 노드 삭제 후 출력 (없으면 X) - d
	Node* tmp = treeSearch(root, key);
	Node* zs;

	if (isExternal(tmp))
		printf("X\n");
	else {
		Node* z = tmp->leftChild;

		if (!isExternal(z))
			z = tmp->rightChild;

		if (isExternal(z))
			zs = reduceExternal(z);
		else {
			Node* y = inOrderSucc(tmp);
			z = y->leftChild;
			tmp->key = y->key;
			zs = reduceExternal(z);
		}
		printf("%d\n", key);
	}
	return;
}

void printPreorder(Node* tmp) { //전위순회 인쇄
	if (isExternal(tmp))
		return;

	printf(" %d", tmp->key);
	printPreorder(tmp->leftChild);
	printPreorder(tmp->rightChild);
}

int main() {
	char order;
	int key;
	root = getNode();

	while (1) {
		scanf("%c", &order);
		if (order == 'q') { //프로그램 종료
			break;
		}
		else if (order == 'i') { //키에 대한 노드 생성 및 트리에 삽입
			scanf("%d", &key);
			insertItem(key);
		}
		else if (order == 'd') { //키에 대한 노드 삭제 후 출력 (없으면 X)
			scanf("%d", &key);
			removeElement(key);
		}
		else if (order == 's') { //키에 대한 노드 출력 (없으면 X)
			scanf("%d", &key);
			findElement(key);
		}
		else if (order == 'p') { //전위순회 인쇄
			printPreorder(root);
			printf("\n");
		}
	}
	return 0;
}
```

**2번,3번. AVL트리**
```c
# include <stdio.h>
# include <stdlib.h>
# pragma warning(disable:4996)

# define swap(x, y) do {int tmp = x; x = y; y = tmp;}while(0)
# define FALSE 0
# define TRUE 1

typedef struct node {
	struct node* leftChild;
	struct node* rightChild;
	struct node* parent;
	int key;
	int height;
}Node;

Node* root;

Node* getNode() {
	Node* horse = (Node*)malloc(sizeof(Node));
	horse->key = 0;
	horse->height = 0;
	horse->parent = horse->leftChild = horse->rightChild = NULL;
	return horse;
}

//---------------------------------(AVL 트리)----------------------------------//
int isBalanced(Node* tmp) { // 노드의 높이 균형 여부 반환

	Node* l = tmp->leftChild;
	Node* r = tmp->rightChild;

	int height = l->height - r->height;

	if (height < 0)
		height = -height;

	if (height < 2)
		return TRUE;

	return	FALSE;
}

int updateHeight(Node* tmp) { //노드의 높이 갱신 여부 반환

	Node* l = tmp->leftChild;
	Node* r = tmp->rightChild;
	int h = (l->height > r->height ? l->height : r->height) + 1;

	if (h != tmp->height) {
		tmp->height = h;
		return TRUE;
	}
	return FALSE;
}

Node* restructure(Node* x, Node* y, Node* z) { //3-노드 개조 수행, 갱신된 3-노드 루트 반환
	Node* a, * b, * c;
	Node* T[4];

	if (z->key < y->key && y->key < x->key) {
		a = z;
		b = y;
		c = x;
		T[0] = a->leftChild;
		T[1] = b->leftChild;
		T[2] = c->leftChild;
		T[3] = c->rightChild;
	}
	else if (x->key < y->key && y->key < z->key) {
		a = x;
		b = y;
		c = z;
		T[0] = a->leftChild;
		T[1] = a->rightChild;
		T[2] = b->rightChild;
		T[3] = c->rightChild;
	}
	else if (z->key < x->key && x->key < y->key) {
		a = z;
		b = x;
		c = y;
		T[0] = a->leftChild;
		T[1] = b->leftChild;
		T[2] = b->rightChild;
		T[3] = c->rightChild;
	}
	else {
		a = y;
		b = x;
		c = z;
		T[0] = a->leftChild;
		T[1] = b->leftChild;
		T[2] = b->rightChild;
		T[3] = c->rightChild;
	}

	if (root == z) {
		root = b;
		b->parent = NULL;
	}
	else if (z->parent->leftChild == z) {
		z->parent->leftChild = b;
		b->parent = z->parent;
	}
	else {
		z->parent->rightChild = b;
		b->parent = z->parent;
	}

	a->leftChild = T[0];
	T[0]->parent = a;
	a->rightChild = T[1];
	T[1]->parent = a;
	updateHeight(a);

	c->leftChild = T[2];
	T[2]->parent = c;
	c->rightChild = T[3];
	T[3]->parent = c;
	updateHeight(c);

	b->leftChild = a;
	a->parent = b;
	b->rightChild = c;
	c->parent = b;
	updateHeight(b);

	return b;
}

void searchAndFixAfterInsertion(Node* tmp) { //균형검사 수행
	Node* x, * y, * z;

	if (tmp == root)
		return;

	z = tmp->parent;
	updateHeight(z);

	while (isBalanced(z)) {
		if (z == root)
			return;

		z = z->parent;
		updateHeight(z);
	}

	if (z->leftChild->height > z->rightChild->height)
		y = z->leftChild;
	else
		y = z->rightChild;

	if (y->leftChild->height > y->rightChild->height)
		x = y->leftChild;
	else
		x = y->rightChild;

	restructure(x, y, z);
	return;
}

void searchAndFixAfterRmoval(Node* tmp) {
	Node* temp, * x, * y, * z = tmp;

	if (z == NULL)
		return;

	updateHeight(z);

	while (isBalanced(z)) {
		if (z == root)
			return;
		z = z->parent;
		updateHeight(z);
	}

	if (isBalanced(z))
		return;

	if (z->leftChild->height > z->rightChild->height)
		y = z->leftChild;
	else
		y = z->rightChild;

	if (y->leftChild->height > y->rightChild->height)
		x = y->leftChild;
	else if (y->leftChild->height < y->rightChild->height)
		x = y->rightChild;
	else {
		if (z->leftChild == y)
			x = y->leftChild;
		else
			x = y->rightChild;
	}

	temp = restructure(x, y, z);
	searchAndFixAfterRmoval(temp->parent);

	return;
}
//---------------------------------(AVL 트리)----------------------------------//

int isExternal(Node* tmp) { //노드가 외부노드인가?
	if (tmp->leftChild == NULL && tmp->rightChild == NULL)
		return TRUE;

	return FALSE;
}

Node* inOrderSucc(Node* tmp) { //노드의 중위순회 후계자 반환
	tmp = tmp->rightChild;
	while (!isExternal(tmp->leftChild)) { //내부노드이면(외부노드 판단의 반대)
		tmp = tmp->leftChild;
	}
	return tmp;
}

void expandExternal(Node* tmp) {
	Node* lChild = getNode();
	Node* rChild = getNode();
	lChild->parent = tmp;
	rChild->parent = tmp;
	tmp->leftChild = lChild;
	tmp->rightChild = rChild;
	tmp->height = 1;
	return;
}

Node* findSibling(Node* tmp) {
	if (tmp->parent->leftChild == tmp)
		return tmp->parent->rightChild;

	return tmp->parent->leftChild;
}

Node* reduceExternal(Node* tmp) {
	Node* parent = tmp->parent;
	Node* sibling = findSibling(tmp);
	Node* grandParent = parent->parent;

	if (parent == root)	{
		root = sibling;
		sibling->parent = NULL;
	}
	else {
		sibling->parent = grandParent;
		if (parent == grandParent->leftChild)
			grandParent->leftChild = sibling;
		else
			grandParent->rightChild = sibling;
	}
	free(tmp);
	free(parent);
	return sibling;
}

Node* treeSearch(Node* tmp, int key) { //키를 저장한 내부 노드 반환
	if (isExternal(tmp))
		return tmp;
	if (key == tmp->key)
		return tmp;
	else if (key < tmp->key)
		return treeSearch(tmp->leftChild, key);
	else
		return treeSearch(tmp->rightChild, key);
}

void insertItem(int key) { //키에 대한 노드 생성 및 트리에 삽입 - i
	Node* tmp = treeSearch(root, key);

	if (!isExternal(tmp))
		return;
	else {
		tmp->key = key;
		expandExternal(tmp);
		searchAndFixAfterInsertion(tmp);
		return;
	}
}

void findElement(int key) { //키에 대한 노드 출력 (없으면 X) - s
	Node* tmp = treeSearch(root, key);

	if (isExternal(tmp))
		printf("X\n");
	else
		printf("%d\n", tmp->key);
	return;
}

void removeElement(int key) { //키에 대한 노드 삭제 후 출력 (없으면 X) - d
	Node* tmp = treeSearch(root, key);
	Node* zs;

	if (isExternal(tmp))
		printf("X\n");
	else {
		Node* z = tmp->leftChild;

		if (!isExternal(z))
			z = tmp->rightChild;

		if (isExternal(z))
			zs = reduceExternal(z);
		else {
			Node* y = inOrderSucc(tmp);
			z = y->leftChild;
			tmp->key = y->key;
			zs = reduceExternal(z);
		}
		searchAndFixAfterRmoval(zs->parent);
		printf("%d\n", key);
	}
	return;
}

void printPreorder(Node* tmp) { //전위순회 인쇄
	if (isExternal(tmp))
		return;

	printf(" %d", tmp->key);
	printPreorder(tmp->leftChild);
	printPreorder(tmp->rightChild);
}

int main() {
	char order;
	int key;
	root = getNode();

	while (1) {
		scanf("%c", &order);
		if (order == 'q') { //프로그램 종료
			break;
		}
		else if (order == 'i') { //키에 대한 노드 생성 및 트리에 삽입
			scanf("%d", &key);
			insertItem(key);
		}
		else if (order == 'd') { //키에 대한 노드 삭제 후 출력 (없으면 X)
			scanf("%d", &key);
			removeElement(key);
		}
		else if (order == 's') { //키에 대한 노드 출력 (없으면 X)
			scanf("%d", &key);
			findElement(key);
		}
		else if (order == 'p') { //전위순회 인쇄
			printPreorder(root);
			printf("\n");
		}
	}
	return 0;
}
```
